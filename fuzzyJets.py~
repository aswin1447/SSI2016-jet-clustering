import sys
import numpy as np
from numpy import matlib
from scipy.stats import multivariate_normal
from read_data import read_data
import matplotlib.pyplot as plt
import time

########## Description of Algorithm ###########
# We will assume having m events
# Each event should have k=3 jets
# Each event should have n 'parrticles' to be clustered into the k jets
# Input: cells  (size = [m,k,2])
#            np vector of size m
#                 each entry is a np vector of size k
#                       each entry of the above vector is of size d=2 dimentions (eta, phi)
# Input: energies   (size = [m,k,1])
#            similar structure as cells, but only energy information

def visualize(particles, mu, sigma, pi):
    x, y, e = zip(*particles)
    print len(x), len(y), len(e)
    plt.scatter(x, y)
    pass
"""
    binx = np.linspace(-3.0, 3.0, 61)
    biny = np.linspace(-3.1, 3.1, 63)
    particleX = particles[:][0]
    particleY = particles[:][1]
    particlePt = particles[:][2]
    #colors = []
    particleArea = [2]*len(particles)
    #plt.hist2d(X[:, 0], X[:, 1], weights=e.ravel(), bins=(binx, biny))
    #plt.hist2d(particleX,particleY,bins=(binx,biny))
    for myJ in range(numK):
        jetX = mu[myJ][0]
        jetY = mu[myJ][1]
        print jetX, jetY
        #plt.hist2d(jetX,jetY,weights=sigma[myJ], bins=(binx,biny))
    #colors = ['blue','green','red','cyan','magenta','yellow']
    #plt.scatter(jetX,jetY,s=sigma,c=colors[0:len(sigma)],alpha=0.5)
    plt.show()
    #import code; code.interact(local=locals())
    plt.clf()
"""

def jetFunction(particleVec,mu,sigma):
    #print particleVec
    #print mu
    myPhi1 = abs(particleVec[1]-mu[1])
    myPhi2 = abs(particleVec[1]-(mu[1]+2*np.pi))
    myPhi3 = abs(particleVec[1]-(mu[1]-2*np.pi))
    absdeltaPhi = min(myPhi1, myPhi2, myPhi3)
    deltaR = np.sqrt((absdeltaPhi)**2 + (particleVec[0]-mu[0])**2)
    denom = 2*np.pi*(sigma**2)
    numerator = np.exp(-deltaR**2/(denom))
    return numerator/denom

def expectation(mu, sigma, pi, particles):
    k = len(mu)
    d = 2
    Q = np.empty((len(particles),k))
    for i in range(len(particles)):
        for j in range(k):
            denom = 0
            for jP in range(k):
                denom += pi[jP]*jetFunction(particles[i],mu[jP],sigma[jP])
            Q[i,j] = pi[j]*jetFunction(particles[i], mu[j], sigma[j])/denom
    return Q
            
def maximization(Q, particles):
    #print "particles2", particles
    eventNumber = 0
    k = len(mu)
    d = 2 #2-d grid
    allSigma = [] #Note that what goes in here is sigma and not sigma^2 (scalars)
    allMu = [] #Each entry is a 2-vector
    allPi = [] #scalars
    for j in range(k):
        newMu = [0.,0.]
        newSigma = 0.
        newPi = 0.
        piDenom = 0.
        muDenom = 0.
        for i in range(len(particles)):
            piDenom += particles[i][2]
            muDenom += particles[i][2] * Q[i][j]
            newPi += particles[i][2] * Q[i][j]
            for c in range(d):
                newMu[c] += particles[i][2] * Q[i][j] * particles[i][c]
        newMu = newMu/muDenom
        newPi = newPi/piDenom
                
        for l in range(len(particles)):
            phi1 = abs(particles[i][1]-newMu[1])
            phi2 = abs(particles[i][1]-(newMu[1]+2*np.pi))
            phi3 = abs(particles[i][1]-(newMu[1]-2*np.pi))
            absdeltaPhi = min(phi1, phi2, phi3)
            deltaR = np.sqrt((absdeltaPhi)**2 + (particles[i][0]-newMu[0])**2)
            newSigma += deltaR**2
        newSigma = newSigma/(1.*muDenom)
        allMu.append(newMu)
        allPi.append(newPi)
        allSigma.append(np.sqrt(np.abs(newSigma)))
    return allMu, allSigma, allPi

if __name__ == '__main__':
    debug = True
    eventNumber = 0
    ### Read in data ###
    particles = []
    myX, myE = read_data()
    for i in range(len(myE[eventNumber])):
        newEntry = []
        newEntry.append(myX[eventNumber][i][0])
        newEntry.append(myX[eventNumber][i][1])
        newEntry.append(myE[eventNumber][i][0])
        particles.append(newEntry)
    
    if debug:
        print "particles", particles
        
    ### InitializeParameters ###
    #numK = NAntiKt4
    numK = 3
    d = 2
    pi = [1./numK]*numK #length k
    sigma = [1.]*numK #length k
    #mu = SEED WITH ANTIKT
    mu = [np.random.randn(2) for i in range(numK)] #length k
    numParticles = len(particles) #total number of partcles in event
    epsilon = 0.4/1000 #pt cone / 1000
    convergedArr = [False]*numK


    while True:
        
        if debug:
            print "Pi", pi
            print "mu", mu
            print "sigma", sigma
            print "bool", convergedArr
            
        ### Expectation Step ###
        Q = expectation(mu, sigma, pi, particles)
        if debug:
            print "Q: ", Q
            
        ### Maximization ###
        muPrime, sigmaPrime, piPrime = maximization(Q, particles)
        
        ### Convergence Criteria ###
        for i in range(numK):
            absdeltaPhi = min(abs(mu[i][1]-muPrime[i][1]),abs(mu[i][1]-(muPrime[i][1]+2*np.pi)),abs(mu[i][1]-(muPrime[i][1]-2*np.pi)))
            deltaR = np.sqrt((absdeltaPhi)**2 + (mu[i][0]-muPrime[i][0])**2)
            if deltaR < epsilon:
                convergedArr[i] = True

        ### Update ###
        mu = muPrime
        sigma = sigmaPrime
        pi = piPrime

        ### Visualization ###
        visualize(particles, mu, sigma, pi)
        
        
        ### Exit Criteria ###
        if convergedArr == [True]*numK:
            break
        
    arrLab = ["First","Second","Third","Fourth","Fifth","Sixth","Seventh","Eigth","Ninth"]
    for i in range(len(mu)):
        print arrLab[i]+" centroid: eta="+str(mu[i][0])+", phi="+str(mu[i][1])+", weight="+str(pi[i])+", sigma="+str(sigma[i])
